async fetchPools() {
  try {
    let allPools = [];
    const seenAddresses = new Set();
    const sources = [];

    // Fetch BOTH DLMM and DAMM v2 in parallel
    const [dlmmResult, dammResult] = await Promise.allSettled([
      fetch('https://dlmm-api.meteora.ag/pair/all').then(r => {
        if (!r.ok) throw new Error(`DLMM HTTP ${r.status}`);
        return r.json();
      }),
      fetch('https://dammv2-api.meteora.ag/pools?limit=200&order_by=tvl&order=desc').then(r => {
        if (!r.ok) throw new Error(`DAMM v2 HTTP ${r.status}`);
        return r.json();
      })
    ]);

    // DLMM
    if (dlmmResult.status === 'fulfilled' && Array.isArray(dlmmResult.value)) {
      const dlmmPools = dlmmResult.value
        .filter(p => p.name && p.address && !p.hide && !p.is_blacklisted && parseFloat(p.liquidity || 0) > 100)
        .map(p => this.processDLMM(p));

      for (const p of dlmmPools) {
        if (!seenAddresses.has(p.address)) {
          seenAddresses.add(p.address);
          allPools.push(p);
        }
      }

      sources.push(`DLMM:${dlmmPools.length}`);
    }

    // DAMM v2
    if (dammResult.status === 'fulfilled' && dammResult.value?.data) {
      let added = 0;
      const dammPools = dammResult.value.data
        .filter(p => p.pool_address && (p.tvl || 0) > 100)
        .map(p => this.processDAMMv2(p));

      for (const p of dammPools) {
        if (!seenAddresses.has(p.address)) {
          seenAddresses.add(p.address);
          allPools.push(p);
          added++;
        }
      }

      sources.push(`DAMM:${added}`);
    }

    // Fallbacks
    if (allPools.length === 0) {
      try {
        const dxr = await fetch('https://api.dexscreener.com/latest/dex/search?q=meteora');
        if (dxr.ok) {
          const dx = await dxr.json();
          allPools = dx.pairs
            ?.filter(p => p.dexId === 'meteora' && p.liquidity?.usd > 100)
            .slice(0, 150)
            .map(p => this.processDexScreener(p)) || [];
          if (allPools.length) sources.push(`DexScreener:${allPools.length}`);
        }
      } catch {}
    }

    if (allPools.length === 0) {
      throw new Error('No pools from any source');
    }

    // âœ… THIS WAS MISSING
    State.pools = allPools;
    State.sources = sources;

  } catch (err) {
    console.error('fetchPools error:', err);
    setTimeout(() => this.fetchPools(), 10000);
  }
}
